#include "player.h"


unsigned int getRandInt(const unsigned int limit)
{
    // limit the random number to the max as the operator %
    // gives the residual of the division.
    // Thus if we divide the random number generated by rand()
    // by "max" the residual of the division can only be smaller
    // then "max"
    return static_cast<unsigned int>(rand()) % limit;
}


//  Initialize with list constructor
Player::Player(const bool human) : is_human(human)
  //    here you put the comma separated list of you member
  //    to initialize. Once you open the bracket the object
  //    is created and once so, you cannot change values of
  //    const members.
{
//    //  Ranged based for loop
//    for(auto& row : player_grid)
//        for(auto& box : row)
//            box.content = 0;

    //  This is a way to initialize a vector
    // In the parentesis we initialize the the pair where the
    // numbers are separeted by a comma
    std::vector<std::pair<unsigned int, unsigned int>> boats_list{
        //  This is a list containing the length of the boats and the
        //  boat id as a std::pair<boat lenght, boat id>
        {5, 1}, //  Aircraft
        {4, 2}, //  Cruise
        {3, 3}, //  Destroyer
        {3, 4}  //  Submarine
    };


    //  This routine is indipendent on how many boat you want to place and
    //  their type/length. Try too keep things separated. For example in
    //  this case if you want to add a boat you just add it in the list
    //  and you are good to go.
    for (const auto& [boat_length, boat_id]: boats_list) {

        bool replace_boat = true;

        //  Declare our variable for the boat addresses
        std::vector<std::pair<unsigned int,
        unsigned int>> boat_addresses;


        //  Iterate untill all the addresses are free
        while (replace_boat) {

            //  Assume everything is ok
            replace_boat =false;

            //  Get the addresses where we could place the boat
            boat_addresses = placeBoatRandomly(boat_length);

            //  Check if addresses are occupied
            for(const auto& [row, col] : boat_addresses){
                //  Take every address in the list generated for the
                //  boat and check the corresponding content of the grid

                //  Check the content
                if(player_grid[row][col].content != 0){//Zero is the sea
                    //  Place boat again
                    replace_boat = true;
                }
            }
        }   //end of while
        //  If we arrive here means that the boat can be placed

        for(const auto& [row, col] : boat_addresses)
            player_grid[row][col].content = boat_id;
                                  //boat_type

    }


}

// Define what the function does in the .cpp
void Player::showPlayerGrid(Player opponent)
{
    //  print columns number for player 1
    std::cout << "  ";
    for(unsigned int col=0; col<columns_number; col++){
        std::cout << col << " ";
    }
    //  print columns number for player 2
    std::cout << "  ";
    for(unsigned int col=0; col<columns_number; col++){
        std::cout << col << " ";
    }

    std::cout << std::endl;

    for (unsigned int row=0;row< rows_number;row++) {

        printGridLine(row);

        opponent.printGridLine(row);

        std::cout << std::endl;

    }

    std::cout << std::endl;
}

void Player::printGridLine(const unsigned int row)
{
    std::cout << row << " ";
    for(unsigned int col=0; col<columns_number; col++){
        //  Reverse the boolean value with the exlamation point
        //  To hide or not the player grid
        player_grid[row][col].printBoxContent(!is_human);
    }
}


void Player::shootAtPlayer(Player &opponent)
{
    //  Start shooting at fixed location
    unsigned int row;
    unsigned int col;

    if(is_human){
        showPlayerGrid(opponent);
        std::cout << "Write your target location [row, col]: ";
        std::cin >> row >> col;
    }else {
        row = getRandInt(rows_number);
        col = getRandInt(columns_number);
    }

    std::cout << "I am shooting at [row, col] : ";
    std::cout << "[" << row << ", " << col << "]" << std::endl << std::endl;

    //  At this point we should change something in
    //  this player grid to account for the shooting

    /*
     * We defined player grid to be private.
     * As a result you cannot access it direcly.
     * However, in C++ is possible to access private members
     * from the same object type.
     */
    opponent.player_grid[row][col].hit = true;
}

bool Player::isPlayerInGame()
{
    /*
     * Check every box of the grid. If we find even one boat
     * that has not been hit it means that the player is
     * still in the game
     */
    for (const auto& row : player_grid) {
        for (const auto& box : row) {
            if(box.content != 0)
                if(!box.hit)
                    return true;
            //  return will end the function execution
        }
    }
    //  If we exit the the two for loops it means we have not
    //  found any safe boat so the plater is out
    return false;
}


//  This function generate the addresses (row and col) coved by the ship
std::vector<std::pair<unsigned int,
unsigned int>> Player::placeBoatRandomly(const unsigned int boat_length)
{
    //  A vector that contains the stack of adresses covered by the boat
    std::vector<std::pair<unsigned int, unsigned int>> boat_addresses;

    //  Randmly get if boat is vertical or horyzontal
    const bool vertical_boat = getRandInt(2);

    //  Declare variable for the first box of the boat
    unsigned int row, col;

    if(vertical_boat){
        row = getRandInt(10 - boat_length);
        col = getRandInt(10);
    } else {
        col = getRandInt(10 - boat_length);
        row = getRandInt(10);
    }

    for(unsigned int step=0; step<boat_length; step++){
        if(vertical_boat)
            boat_addresses.push_back({row + step, col});
        //  Add an element in the end of the vector
        else
            boat_addresses.push_back({row, col + step});
    }

    //  Return the generated vector
    return boat_addresses;
}
